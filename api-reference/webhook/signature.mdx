---
title: "Security Verification"
description: "Once the key is generated, its time to implement the verification on your end."
---

When PayInGame sends a webhook to your endpoint, it includes a header called:

<pre>Payingame-Signature</pre>

This header lets you verify that the webhook was sent by PayInGame, not a malicious third party.

# Header Structure

The header looks like this:

<pre>
  t=1762795211,v1=d4ec6316d9dcbbc06db0a18bdf8cdb73c8865d4d5134c9890ba39a15a8f17b26
</pre>

- t: Unix timestamp (in seconds) when the webhook was generated
- v1: HMAC-SHA256 signature of the payload, computed using your secret key

# How It Works

When your project’s webhook is triggered, we compute:

<pre>signedPayload = "timestamp.raw_body"</pre>

Then we sign that payload using your webhook secret key (a 256-bit hex string) with HMAC-SHA256:

<pre>hmacValue = hmac(signedPayload, secretKey, "HMACSHA256", "UTF-8")</pre>

# Example

Example webhook payload:

```json
{
  "PaymentGuid": "9C4E0E58-ABF8-DFC3-D130-EF993228349F",
  "ProjectGuid": "5E3E59A2-FC03-88DE-6135-C05FAE5BA7B2",
  "Quantity": 1,
  "Products": [
    "7BC62A19-E33F-E99D-F582-B720FF46A8CA",
    "7BC62A19-E33F-E99D-F582-B720FF46A8CA"
  ],
  "UserID": "Cus123"
}
```

Example signature header:

```
Payingame-Signature: t=1762795211,v1=d4ec6316d9dcbbc06db0a18bdf8cdb73c8865d4d5134c9890ba39a15a8f17b26

```

Example secret key:

```
e3cf0f521274f2badab694b0b8c861823aae5b33a59eb4809332dc03bdb9297b
```

Computed HMAC:

```
hmac("1762795211.{raw_body}", secretKey, "HMACSHA256")
```

This results in:

```
d4ec6316d9dcbbc06db0a18bdf8cdb73c8865d4d5134c9890ba39a15a8f17b26
```

Receiver side (example .net)

```tabs
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("api/[controller]")]
public class WebhookController : ControllerBase
{
    // Your 256-bit hex secret from the PayInGame dashboard
    private const string SecretKey = "e3cf0f521274f2badab694b0b8c861823aae5b33a59eb4809332dc03bdb9297b";

    [HttpPost]
    public async Task<IActionResult> ReceiveWebhook()
    {
        // 1️⃣ Read the raw request body exactly as sent
        string body;
        using (var reader = new StreamReader(Request.Body))
            body = await reader.ReadToEndAsync();

        // 2️⃣ Get the Payingame-Signature header
        if (!Request.Headers.TryGetValue("Payingame-Signature", out var sigHeader))
            return Unauthorized("Missing Payingame-Signature header");

        // 3️⃣ Parse the t= and v1= values
        var parts = sigHeader.ToString()
            .Split(',', StringSplitOptions.RemoveEmptyEntries)
            .Select(p => p.Trim().Split('='))
            .ToDictionary(p => p[0], p => p[1]);

        if (!parts.TryGetValue("t", out var timestamp))
            return Unauthorized("Missing timestamp");

        if (!parts.TryGetValue("v1", out var receivedSignature))
            return Unauthorized("Missing signature");

        // 4️⃣ Build message to verify: "timestamp.body"
        var message = $"{timestamp}.{body}";

        // 5️⃣ Compute HMAC-SHA256 using the shared secret
        var secretBytes = Convert.FromHexString(SecretKey);
        string computedSignature;
        using (var hmac = new HMACSHA256(secretBytes))
        {
            var hash = hmac.ComputeHash(Encoding.UTF8.GetBytes(message));
            computedSignature = Convert.ToHexString(hash).ToLower();
        }

        // 6️⃣ Compare safely (constant time)
        if (SecureEquals(computedSignature, receivedSignature))
        {
            Console.WriteLine("✅ Verified webhook!");
            return Ok();
        }
        else
        {
            Console.WriteLine("❌ Invalid signature");
            return Unauthorized();
        }
    }

    private static bool SecureEquals(string a, string b)
    {
        if (a.Length != b.Length) return false;
        int diff = 0;
        for (int i = 0; i < a.Length; i++)
            diff |= a[i] ^ b[i];
        return diff == 0;
    }
}


```
